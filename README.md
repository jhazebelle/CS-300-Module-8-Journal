# CS-300-Module-8-Journal

In this course, I worked on two connected projects focused on data structures and algorithms. The main problem I solved was figuring out how to efficiently store, search, and display course data for the Computer Science program. I analyzed the runtime and memory tradeoffs for different data structures vectors with maps, hash tables, and binary search trees (BSTs) to determine which would be the most effective for loading and validating data. I chose to implement a BST because it allows the course list to print automatically in sorted order using in order traversal, making it both elegant and efficient. Understanding these data structures helped me see why picking the right one can dramatically affect performance, especially when working with large datasets.

When I ran into roadblocks, like handling edge cases for missing prerequisites or parsing CSV lines cleanly, I broke down the problem into smaller parts and tested each one before moving on. For example, I created helper functions to trim whitespace, split CSV lines, and convert course numbers to uppercase so user input would be case insensitive. This step by step debugging approach made the whole program more reliable.

These projects expanded how I approach software design by reminding me that structure matters as much as logic. Choosing the right data structure is like setting the foundation for everything else, as it impacts runtime, memory use, and even code readability. I’ve also learned to write code that’s maintainable and adaptable by keeping it modular, adding comments to explain decisions, and organizing functions logically. If I ever revisit this project later, I’ll immediately understand how and why each part works. Overall, this experience made me more confident designing programs that are efficient, clear, and built to evolve.
